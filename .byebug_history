continue
18.601075237738275 ** 2
Math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)
(point1[1] - point2[1])**2
(point1[0] - point2[0])**2
point2 = beacon.location
point1 = point 
beacon.location
point
real_distance = distance_between_two_points(point, beacon.location)
expected_distance = beacon.distance 
continue
score += (expected_distance-real_distance).abs
real_distance = distance_between_two_points(point, beacon.location)
expected_distance = beacon.distance 
beacon
exit
last_score
continue
last_score
continue
last_score
last_Score
mutation_factor <= 0.1
mutation_factor
continue
mutation_factor
continue
mutation_factor
continue
mutation_factor
continue
mutation_factor
continue
mutation_factor
continue
mutation_factor
exit
continue
last_score
min_score
point[1]
point[1] + mutation_factor 
point
point-1
last_score
[left,right,up,down]
min_score
continue
mutate(point, last_score, mutation_factor/2.0)
mutation_factor/2.0
mutation_factor
last_score
max_score
continue
score
continue
beacon
continue
@beacons.sort_by {|beacon| beacon.distance }.firstcontinue
@beacons.sort_by {|beacon| beacon.distance }
@beacons.sort_by {|a,b| a.distance }
@beacons.sort_by {|a,b| a.distance <=> b.distance }
@beacons.sort_by
continue
point_permutations_score.sort[0]
point_permutations_score.sort
poo
continue
point_permutations.each
continue
point_permutations
continue
[0,1,2] && [1]
range =Array(ranges[1..-1]).first
comparitor = Array.new(ranges.first)
continue
 overlap(@beacons.map{|b| b.range(:x)})
(@beacons.map{|b| b.range(:x)})
@beacons
continue
 Calculator.solve(1,1,0)
